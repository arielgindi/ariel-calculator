<div dir="rtl">

# Gindi Calculator

## איך המחשבון בכלל עובד?

1. **Tokenize**  
   המחשבון לוקח את המחרוזת שהמשתמש כתב וממירה אותו למערך של Tokens  
   לדוגמא המחרוזת הזאת: "12.5*2"  
   יוחזר: [NUMBER(12.5), OPERATOR(*), NUMBER(2)]

2. **Normalize Unary**  
   הקוד מבדיל בין שלושה סוגי מינוסים, מצאתי שזאת הדרך הכי פשוטה להתמודד עם הסיבוכיות בפשטות:  
   - מינוס אונרי רגיל (u-): קדימות 3.5 (בין ^ ל-%).  
   - מינוס אונרי אחרי אופרטור (b-): קדימות גבוהה ביותר 6.5.  
   - מינוס בינארי (-): קדימות 1.  

   התהליך ממיר כל מינוס לסוג המתאים (u-/b-/-) לפי המיקום שלו בביטוי.

3. **Validate Tilda**  
   בודק את התקינות של הטילדה ~, למשל שלא תהיה ~~ רצופה.

4. **Convert to Postfix**  
   אני לוקח את הביטוי וממיר אותו לpostfix. החלק הזה מסדר את האופרציות לפי הקדימות הנכונה.

5. **Postfix Calculator**  
   מחשב את הביטוי הpostfix ומחזיר את הערך הסופי.

---

## למה בחרתי להשתמש ב־OPERATORS במקום מחלקות נפרדות, בניגוד לחלק מחברי הכיתה?
במקום ליצור לכל אופרטור מחלקה נפרדת, הכנסתי את כל המידע (קדימות, פונקציית חישוב, האם אונארי וכו) למילון אחד בשם OPERATORS.  
זה הופך את הקוד ליותר קריא ופשוט להרחבה. אם רוצים להוסיף אופרטור חדש (כמו # לחיבור ספרות), פשוט מוסיפים שורה באותו מילון, ולא צריך מחלקה חדשה או שינוי נוסף בקוד. כך רואים הכל בבירור ומשווים בין האופרטורים בלי יותר מדי חיפושים, וגם שומרים על קוד נקי. היה ניתן ליצור עשרות קבצים ומחלקות לכל האופרטורים, מה שאני עשיתי בכמה שורות.

---

## ניהול פרויקט ב־Git
במהלך העבודה השתמשתי ב branches, כפי שנדרש.  
בסיום העבודה על branch מסוים, לרוב מחקתי אותו כדי לשמור על repo נקי (אם אין צורך לחזור אליו). לכן בהיסטוריה לא רואים את כל branches שבהם השתמשתי, כי ככה נהוג לעבוד על פי הקונבנציה של Git, עד שלא שאלתי בקבוצת וואטסאפ של המחשבון, מחקתי branches לא שימושיים ולכן ההיסטוריה לא נראית מלאה, למרות שכן עבדתי נכון עם Git.

</div>
